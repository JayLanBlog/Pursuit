#include "gl_view.h"
#include <rmd/gl/gl_global.h>
#include <math/pr_math.h>
#include <logger/logger.h>
#include <core/pcarmera.h>
using namespace PMath;

//----------------------------------------------------------------------------------
// Global Variables Definition
//----------------------------------------------------------------------------------
static double CullDistanceNear = PL_CULL_DISTANCE_NEAR;
static double CullDistanceFar = PL_CULL_DISTANCE_FAR;

namespace DRAW {
	namespace GL {
#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
		// Choose the current matrix to be transformed
		void MatrixMode(int mode) {
			if (mode == PL_PROJECTION) PLGL.State.currentMatrix = &PLGL.State.projection;
			else if (mode == PL_MODELVIEW) PLGL.State.currentMatrix = &PLGL.State.modelview;
			//else if (mode == RL_TEXTURE) // Not supported
			PLGL.State.currentMatrixMode = mode;
		}

		// Push the current matrix into PLGL.State.stack
		void PushMatrix(void) {
			if (PLGL.State.stackCounter >= PL_MAX_MATRIX_STACK_SIZE) TRACELOG(LOG_ERROR, "PLGL: Matrix stack overflow (RL_MAX_MATRIX_STACK_SIZE)");

			if (PLGL.State.currentMatrixMode == PL_MODELVIEW)
			{
				PLGL.State.transformRequired = true;
				PLGL.State.currentMatrix = &PLGL.State.transform;
			}
			PLGL.State.stack[PLGL.State.stackCounter] = *PLGL.State.currentMatrix;
			PLGL.State.stackCounter++;
		}

		// Polattest inserted matrix from PLGL.State.stack
		void PopMatrix(void) {
			if (PLGL.State.stackCounter > 0)
			{
				Matrix mat = PLGL.State.stack[PLGL.State.stackCounter - 1];
				*PLGL.State.currentMatrix = mat;
				PLGL.State.stackCounter--;
			}
			if ((PLGL.State.stackCounter == 0) && (PLGL.State.currentMatrixMode == PL_MODELVIEW))
			{
				PLGL.State.currentMatrix = &PLGL.State.modelview;
				PLGL.State.transformRequired = false;
			}
		}

		// Ret current matrix to identity matrix
		void LoadIdentity(void) {
			*PLGL.State.currentMatrix = MatrixIdentity();
		}

		// Multiply the current matrix by a translation matrix
		void Translatef(float x, float y, float z) {
			Matrix matTranslation = {
				1.0f, 0.0f, 0.0f, x,
				0.0f, 1.0f, 0.0f, y,
				0.0f, 0.0f, 1.0f, z,
				0.0f, 0.0f, 0.0f, 1.0f
			};
			// NOTE: We transpose matrix with multiplication order
			*PLGL.State.currentMatrix = MatrixMultiply(matTranslation, *PLGL.State.currentMatrix);
		}

		// Muiply the current matrix by a perspective matrix generated by parameters
		void Frustum(double left, double right, double bottom, double top, double znear, double zfar) {
			Matrix matFrustum = { 0 };
			float rl = (float)(right - left);
			float tb = (float)(top - bottom);
			float fn = (float)(zfar - znear);
			matFrustum.m0 = ((float)znear * 2.0f) / rl;
			matFrustum.m1 = 0.0f;
			matFrustum.m2 = 0.0f;
			matFrustum.m3 = 0.0f;
			matFrustum.m4 = 0.0f;
			matFrustum.m5 = ((float)znear * 2.0f) / tb;
			matFrustum.m6 = 0.0f;
			matFrustum.m7 = 0.0f;
			matFrustum.m8 = ((float)right + (float)left) / rl;
			matFrustum.m9 = ((float)top + (float)bottom) / tb;
			matFrustum.m10 = -((float)zfar + (float)znear) / fn;
			matFrustum.m11 = -1.0f;
			matFrustum.m12 = 0.0f;
			matFrustum.m13 = 0.0f;
			matFrustum.m14 = -((float)zfar * (float)znear * 2.0f) / fn;
			matFrustum.m15 = 0.0f;
			*PLGL.State.currentMatrix = MatrixMultiply(*PLGL.State.currentMatrix, matFrustum);
		}

		// Muiply the current matrix by a scaling matrix
		void Scalef(float x, float y, float z) {
			Matrix matScale = {
	  x, 0.0f, 0.0f, 0.0f,
	  0.0f, y, 0.0f, 0.0f,
	  0.0f, 0.0f, z, 0.0f,
	  0.0f, 0.0f, 0.0f, 1.0f
			};
			// NOTE: We transpose matrix with multiplication order
			*PLGL.State.currentMatrix = MatrixMultiply(matScale, *PLGL.State.currentMatrix);
		}

		// Multiply the current matrix by another matrix
		void MultMatrixf(const float* matf) {
			// Matrix creation from array
			Matrix mat = { matf[0], matf[4], matf[8], matf[12],
						   matf[1], matf[5], matf[9], matf[13],
						   matf[2], matf[6], matf[10], matf[14],
						   matf[3], matf[7], matf[11], matf[15] };
			*PLGL.State.currentMatrix = MatrixMultiply(mat, *PLGL.State.currentMatrix);
		}

		// Multiply the current matrix by a rotation matrix
		// NOTE: The provided angle must be in degrees
		void Rotatef(float angle, float x, float y, float z) {
			Matrix matRotation = MatrixIdentity();
			
			// Axis vector (x, y, z) normalization
			float lengthSquared = x * x + y * y + z * z;
			if ((lengthSquared != 1.0f) && (lengthSquared != 0.0f))
			{
				float inverseLength = 1.0f / sqrtf(lengthSquared);
				x *= inverseLength;
				y *= inverseLength;
				z *= inverseLength;
			}
			// Rotation matrix generation
			float sinres = sinf(DEG2RAD * angle);
			float cosres = cosf(DEG2RAD * angle);
			float t = 1.0f - cosres;
			matRotation.m0 = x * x * t + cosres;
			matRotation.m1 = y * x * t + z * sinres;
			matRotation.m2 = z * x * t - y * sinres;
			matRotation.m3 = 0.0f;
			matRotation.m4 = x * y * t - z * sinres;
			matRotation.m5 = y * y * t + cosres;
			matRotation.m6 = z * y * t + x * sinres;
			matRotation.m7 = 0.0f;
			matRotation.m8 = x * z * t + y * sinres;
			matRotation.m9 = y * z * t - x * sinres;
			matRotation.m10 = z * z * t + cosres;
			matRotation.m11 = 0.0f;
			matRotation.m12 = 0.0f;
			matRotation.m13 = 0.0f;
			matRotation.m14 = 0.0f;
			matRotation.m15 = 1.0f;
			// NOTE: We transpose matrix with multiplication order
			*PLGL.State.currentMatrix = MatrixMultiply(matRotation, *PLGL.State.currentMatrix);
		}

		// Multiply the current matrix by an orthographic matrix generated by parameters
		void Ortho(double left, double right, double bottom, double top, double znear, double zfar) {
			// NOTE: If left-right and top-botton values are equal it could create a division by zero,
  // response to it is platform/compiler dependant
			Matrix matOrtho = { 0 };
			float rl = (float)(right - left);
			float tb = (float)(top - bottom);
			float fn = (float)(zfar - znear);
			matOrtho.m0 = 2.0f / rl;
			matOrtho.m1 = 0.0f;
			matOrtho.m2 = 0.0f;
			matOrtho.m3 = 0.0f;
			matOrtho.m4 = 0.0f;
			matOrtho.m5 = 2.0f / tb;
			matOrtho.m6 = 0.0f;
			matOrtho.m7 = 0.0f;
			matOrtho.m8 = 0.0f;
			matOrtho.m9 = 0.0f;
			matOrtho.m10 = -2.0f / fn;
			matOrtho.m11 = 0.0f;
			matOrtho.m12 = -((float)left + (float)right) / rl;
			matOrtho.m13 = -((float)top + (float)bottom) / tb;
			matOrtho.m14 = -((float)zfar + (float)znear) / fn;
			matOrtho.m15 = 1.0f;
			*PLGL.State.currentMatrix = MatrixMultiply(*PLGL.State.currentMatrix, matOrtho);
		}

		// Set the viewport area (transformation from normalized device coordinates to window coordinates)
		// NOTE: We store current viewport dimensions
		void Viewport(int x, int y, int width, int height) {
			glViewport(x, y, width, height);
		}

		// Set clip planes distances
		void SetClipPlanes(double nearPlane, double farPlane) {
			CullDistanceNear = nearPlane;
			CullDistanceFar = farPlane;
		}

		// Get internal view offset matrix for stereo render (selected eye)
		Matrix GetMatrixViewOffsetStereo(int eye)
		{
			Matrix mat = MatrixIdentity();
#if defined(GRAPHICS_API_OPENGL_33) || defined(GRAPHICS_API_OPENGL_ES2)
			mat = PLGL.State.viewOffsetStereo[eye];
#endif
			return mat;
		}

		// Get cull plane distance far
		double GetCullDistanceFar(void) {
			return CullDistanceFar;
		}
		// Get cull plane distance near
		double GetCullDistanceNear(void)
		{
			return CullDistanceNear;
		}

#endif
	}

}